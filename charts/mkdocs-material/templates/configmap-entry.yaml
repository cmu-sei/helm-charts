{{- if .Values.giturl }}
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ include "mkdocs-material.fullname" . }}-entry
  labels:
    {{- include "mkdocs-material.labels" . | nindent 4 }}

data:
  git-pull.sh: |-
    #!/bin/sh

    #######################################################
    # Execute git command exactly as passed and return
    # stdout in GIT_OUTPUT and stderr in GIT_OUTPUT_ERR.
    # You should enclose the passed command in quotes to
    # avoid shell expansion issues.
    #
    # On failure, cleans out all git state for the next
    # call to this script and exits with the git exit code.
    # Arguments:
    #   git command string
    # Returns:
    #   git output. Exits script on error.
    #######################################################
    execute_git_command() {
        STD_ERR_FILENAME=`mktemp`
        touch "$STD_ERR_FILENAME"
        GIT_OUTPUT=`eval "$@" 2>"$STD_ERR_FILENAME"`
        GIT_EXIT_CODE="$?"
        GIT_OUTPUT_ERR=`cat "$STD_ERR_FILENAME"`
        rm "$STD_ERR_FILENAME"
        if [ "$GIT_EXIT_CODE" -ne "0" ]; then
          echo "Git command failed: $@"
          echo "Output was: ${GIT_OUTPUT}"
          echo "StdErr Output was: ${GIT_OUTPUT_ERR}"
          echo "Exit code was: $GIT_EXIT_CODE"
          echo "Deleting all git state..."
          rm -f "/docs/.dirty"
          cd /git
          find . -mindepth 1 -delete
          exit "$GIT_EXIT_CODE"
        fi
        echo "$GIT_OUTPUT"
        echo "$GIT_OUTPUT_ERR"
    }

    update-ca-certificates

    if [ -n $DOCS_GIT_CRED_FILE ]; then
        execute_git_command "git config --global credential.helper \"store --file=/git-credentials/${DOCS_GIT_CRED_FILE}\""
    fi

    # Keep track of whether docs need to be built
    dirty=0

    ## pull updates (and clone on first attempt)
    cd /git
    if [ ! -d .git ]; then
        echo "Clearing and cloning git repo..."
        dirty=1
        find . -mindepth 1 -delete
        execute_git_command "git clone ${DOCS_GIT_URL} ."
    else
        ## Verify that the repository reference has not changed.
        URL_HOST_AND_PATH_REGEX="^([A-Za-z0-9-]+://)?([A-Za-z0-9-]*.*@)?([\\.A-Za-z0-9-]{1,63})(.*)"
        GIT_REPO_URL=`git remote get-url origin`
        GIT_REPO_HOST_AND_PATH=`echo "$GIT_REPO_URL" | sed -r -e "s#${URL_HOST_AND_PATH_REGEX}#\3\4#"`
        CONFIGURED_HOST_AND_PATH=`echo "$DOCS_GIT_URL" | sed -r -e "s#${URL_HOST_AND_PATH_REGEX}#\3\4#"`
        echo "Git repo host and path: $GIT_REPO_HOST_AND_PATH"
        echo "Configured host and path: $CONFIGURED_HOST_AND_PATH"
        if [ "$GIT_REPO_HOST_AND_PATH" != "$CONFIGURED_HOST_AND_PATH" ]; then
            echo "Configured git repo host and/or path changed."
            echo "Clearing and cloning git repo..."
            dirty=1
            find . -mindepth 1 -delete
            execute_git_command "git clone ${DOCS_GIT_URL} ."
        fi
    fi

    ## Remove all local changes and any untracked files
    execute_git_command "git reset --hard"
    execute_git_command "git clean -f -d"

    if [ -n "$DOCS_GIT_BRANCH" ]; then
        execute_git_command "git checkout ${DOCS_GIT_BRANCH}"
        echo "${GIT_OUTPUT} ${GIT_OUTPUT_ERR}" | grep "Switch*" > /dev/null 2>&1
        if [ "$?" -eq "0" ]; then
            echo "Branch changed - docs should be updated."
            dirty=1
        fi
    fi

    execute_git_command "git fetch --porcelain"

    if [ -n "$GIT_OUTPUT" ]; then
        echo "Changes were made on remote branch - docs should be updated."
        dirty=1
    fi

    execute_git_command "git pull"

    if [ "$dirty" -eq "1" ]; then
        touch "/docs/.dirty"
    fi

    if [ -n "$DOCS_SITE_URL" ]; then
        if [ -n "$DOCS_GIT_PATH" ]; then
            echo "Docs path is: ${DOCS_GIT_PATH}"
            cd "${DOCS_GIT_PATH}"
            if [ "$?" -ne "0" ]; then
                echo "Failed to find the specified directory: ${DOCS_GIT_PATH}"
            fi
        fi

        if [ -f mkdocs.yml ]; then
            sed -i -r -e "s#^(site_url: )(.*)#\1${DOCS_SITE_URL}#" mkdocs.yml
            found_url=`grep -c 'site_url:' mkdocs.yml`
            if [ -z $found_url ]; then
                echo "site_url: ${DOCS_SITE_URL}" | cat - mkdocs.yml > tmp.yml
                mv tmp.yml mkdocs.yml
            fi
        else
            echo "Failed to find the mkdocs.yml file."
        fi
    fi

  mkdocs-build.sh: |-
    #!/bin/sh

    if [ -f "/docs/.dirty" ]; then

        if [ "$MKDOCS_ADD_MACROS" = "true" ]; then
            echo "Installing mkdocs-macros-plugin version ${MKDOCS_MACROS_VERSION}..."
            pip install --no-cache-dir mkdocs-macros-plugin=="$MKDOCS_MACROS_VERSION"
        fi

        echo "Building docs..."

        if [ -n "$DOCS_GIT_PATH" ]; then
            docs_dir="/git/${DOCS_GIT_PATH}"
        else
            docs_dir="/git"
        fi

        if [ -d "$docs_dir" ]; then
            old_docs=`readlink /docs/site`
            new_docs=`mktemp -d -p /docs`

            echo "Old docs: $old_docs"
            echo "New docs: $new_docs"

            echo "Docs directory is: ${docs_dir}"
            cd "$docs_dir"
            mkdocs build -d "$new_docs"
            if [ "$?" -eq "0" ]; then
                echo "Mkdocs build succeeded."

                cd /docs
                tmp_path=`basename "$new_docs"`
                chmod 775 "$tmp_path"

                ## Delete the previous symbolic link
                rm "site"

                ## Relink or link the symbolic link
                ln -s "$tmp_path" "site"

                if [ -n "$old_docs" ]; then
                    echo "Removing old docs: $old_docs"
                    rm -Rf "$old_docs"
                else
                    echo "No old docs to remove"
                fi

                new_docs_link=`ls -alF /docs/site`
                echo "$new_docs_link" | grep "$tmp_path" > /dev/null 2>&1
                if [ "$?" -eq "0" ]; then
                    echo "New link: $new_docs_link"
                    rm "/docs/.dirty"
                else
                    echo "Unexpected link result: $new_docs_link"
                fi
            else
                echo "Mkdocs build failed."
            fi
        else
          echo "Docs directory not found: ${docs_dir}"
        fi
    else
        echo "Docs are up-to-date."
    fi
{{- end }}
