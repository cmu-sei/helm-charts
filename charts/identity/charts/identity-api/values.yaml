# Default values for identity-api.
# This is a YAML-formatted file.
# Declare variables to be passed into your templates.

replicaCount: 1

image:
  repository: cmusei/identity
  pullPolicy: IfNotPresent
  # Overrides the image tag whose default is the chart appVersion.
  tag: ""

imagePullSecrets: []
nameOverride: ""
fullnameOverride: ""

serviceAccount:
  # Specifies whether a service account should be created
  ## If true, also create a Role to support `migrations` (described below)
  ## and a RoleBinding for the new serviceAccount
  create: false
  # Annotations to add to the service account
  annotations: {}
  # The name of the service account to use.
  # If not set and create is true, a name is generated using the fullname template
  name: ""

podAnnotations: {}

podSecurityContext: {}
  # fsGroup: 2000

securityContext: {}
  # capabilities:
  #   drop:
  #   - ALL
  # readOnlyRootFilesystem: true
  # runAsNonRoot: true
  # runAsUser: 1000

service:
  type: ClusterIP
  port: 80

ingress:
  enabled: false
  annotations: {}
    # kubernetes.io/ingress.class: nginx
    # kubernetes.io/tls-acme: "true"
  hosts:
    - host: chart-example.local
      paths: ["/"]
  tls: []
  #  - secretName: chart-example-tls
  #    hosts:
  #      - chart-example.local

health: {}
  # livenessProbe:
  #   initialDelaySeconds: 10
  #   httpGet:
  #     path: /api/version
  #     port: http
  # startupProbe:
  #   initialDelaySeconds: 30
  #   httpGet:
  #     path: /api/version
  #     port: http
  #   failureThreshold: 9
  #   periodSeconds: 10

resources: {}
  # We usually recommend not to specify default resources and to leave this as a conscious
  # choice for the user. This also increases chances charts run on environments with little
  # resources, such as Minikube. If you do want to specify resources, uncomment the following
  # lines, adjust them as necessary, and remove the curly braces after 'resources:'.
  # limits:
  #   cpu: 200m
  #   memory: 512Mi
  # requests:
  #   cpu: 100m
  #   memory: 256Mi

autoscaling:
  enabled: false
  minReplicas: 1
  maxReplicas: 100
  targetCPUUtilizationPercentage: 80
  # targetMemoryUtilizationPercentage: 80

nodeSelector: {}

tolerations: []

affinity: {}

# storage - either an existing pvc, the size for a new pvc, or emptyDir
storage:
  existing: ""
  size: ""
  mode: ReadWriteOnce
  class: default

## migrations sets how data migrations run
## If enabled, all replicas will wait until a single migration job runs.
## this is important if running multiple replicas or if you use different
## connection strings (permissions) for building the database versus using it.
## If using a single connection string, no need to specify here. It will use values
## from `env` below.
## NOTE: the serviceAccount must have permission to `get batch.jobs`.
## If you create the serviceAccount above, it will get a RoleBinding to a Role with that allowed.
migrations:
  enabled: false
  restartPolicy: Never
  Database__Provider: ""
  Database__ConnectionString: ""
  env: {}

# Config app settings with environment vars.
# Those most likely needing values are listed. For others,
# see https://github.com/cmu-sei/Identity/blob/master/src/IdentityServer/appsettings.conf
env:
  # Supported providers: InMemory, PostgreSQL, SqlServer
  Database__Provider: InMemory
  Database__ConnectionString: identity_db
  Branding__ApplicationName: Identity
  Branding__UiHost: /ui
  Cache__Key: idsrv
  Cache__RedisUrl: ""
  Cache__SharedFolder: ""
  Logging__Console__DisableColors: true
  Account__AdminEmail: ""
  Account__AdminPassword: ""
  Account__OverrideCode: ""
  Account__Authentication__SigningCertificate: conf/signer.pfx
  Account__Authentication__SigningCertificatePassword: ""
  Account__Authentication__NoticeFile: "conf/notice.html"
  AppMail__Url: ""
  AppMail__Key: ""
  AppMail__From: ""
  Headers__Cors__Origins__0: ""
  Headers__Cors__Methods__0: ""
  Headers__Cors__Headers__0: ""
  Headers__Cors__AllowCredentials: false
  Headers__Forwarding__TargetHeaders: All


conf:
  issuers: ""
  notice: ""
  terms: ""
  trouble: ""
  seed: ""
  signer: ""
  # seedScript: |
  #   #!/bin/sh -xe
  #   # 
  #   # Copyright 2021 Carnegie Mellon University.
  #   # Released under a BSD (SEI)-style license, please see LICENSE.md in the
  #   # project root or contact permission@sei.cmu.edu for full terms.

  #   #############################
  #   #   Identity Seed Script    #
  #   #############################

  #   # WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING #
  #   #                                                                                         #
  #   # If you are dependant on the id or globalId of an item use the Identity seed file        #
  #   # In many cases this script will delete and re-create items due to limitation of the      #
  #   # Identity API                                                                            #
  #   #                                                                                         #
  #   # WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING #    

  #   APP_NAME=${1}
  #   # If JSON files are not in the same directory as the script 
  #   # Specify the directory as the second argument.
  #   DIRECTORY=${2-$(dirname "$BASH_SOURCE[0]")}
  #   cd $DIRECTORY

  #   # http or https
  #   PROTO="https"
  #   DOMAIN="${DOMAIN:-foundry.local}"

  #   # get access token
  #   ACCESS_TOKEN=$(curl --silent --insecure --request POST \
  #     --url "$PROTO://$DOMAIN/identity/connect/token" \
  #     --data grant_type=password \
  #     --data scope="identity-api identity-api-privileged" \
  #     --data client_id=bootstrap-client \
  #     --data client_secret=foundry \
  #     --data username=administrator@foundry.local \
  #     --data password=foundry | jq -r '.access_token')

  #   # Function exists() 
  #   # Returns ID if the item exists
  #   # returns empty string if it doesn't. 
  #   function exists() {
  #     TYPE=$1
  #     NAME=$2

  #     URL="$PROTO://$DOMAIN/identity/api/${TYPE}s?term=$NAME"
  #     EXISTS=$(curl --silent --insecure --request GET \
  #       --url "$URL" \
  #       -H "Authorization: Bearer $ACCESS_TOKEN" \
  #       -H "Content-Type: application/json")
  #     # RETURN
  #     echo $(printf '%s' "$EXISTS" | jq '.[0].id // empty')
  #   }

  #   function update() {
  #     # TYPE can also be used like a path "resource/enlist" without the quotes
  #     TYPE=$1
  #     NAME=$2
  #     ID=$3
  #     DATA=$4
      
  #     URL="$PROTO://$DOMAIN/identity/api/${TYPE}"
      

  #     API_JSON=$(curl --silent --insecure --request GET \
  #       --url "$URL/$ID" \
  #       -H "Authorization: Bearer $ACCESS_TOKEN" \
  #       -H "Content-Type: application/json" | jq '.')
      
  #     #Combine file and API json
  #     JSON=$(printf '%s' "$API_JSON $DATA" | jq -sr add)
  #     UPDATED=$(curl --insecure --request PUT \
  #     --url "$URL" \
  #     -H "Authorization: Bearer $ACCESS_TOKEN" \
  #     -H "Content-Type: application/json" \
  #     -d "$JSON")
  #     if [[ -n "$UPDATED" ]]; then 
  #       echo "$NAME Updated" 
  #     fi
  #   }

  #   function add() {
  #     TYPE=$1
  #     NAME=$2
  #     DATA=$3
  #     # PROPS is a jq filter string
  #     # In some cases when creating we need a subset of the json data
  #     # e.g. '. | {usernames: .usernames, password: .password}'
  #     PROPS=${4-'.'}
  #     URL="$PROTO://$DOMAIN/identity/api/${TYPE}"
      
  #     # Parse JSON for initial POST
  #       INIT_JSON=$(printf '%s' "$DATA" | jq "$PROPS")
  #       echo "CREATING NEW $TYPE"
  #       #Create the resource, get the resource ID and full resource.
  #       INIT_API=$(curl --insecure --request POST \
  #       --url "$URL" \
  #       -H "Authorization: Bearer $ACCESS_TOKEN" \
  #       -H "Content-Type: application/json" \
  #       -d "$INIT_JSON")
        
  #       ID=$(printf '%s' "$INIT_API" |jq -r '. | if type=="array" then .[0].id else .id end // empty')
        
  #       if [[ -n "$ID" ]]; then
  #         API_JSON=$(curl --insecure --request GET \
  #         --url "$URL/$ID" \
  #         -H "Authorization: Bearer $ACCESS_TOKEN" \
  #         -H "Content-Type: application/json")

  #         # Merge JSON
  #         JSON=$(printf '%s\n%s\n' "$API_JSON" "$DATA" | jq -n '[inputs] | add')
          
  #         # PUT Update
  #         ADDED=$(curl --insecure --request PUT \
  #         --url "$PROTO://$DOMAIN/identity/api/$TYPE" \
  #         -H "Authorization: Bearer $ACCESS_TOKEN" \
  #         -H "Content-Type: application/json" \
  #         -d "$JSON" | jq -r '.')
  #         if [[ -n "$ADDED" ]]; then 
  #           echo $ADDED
  #         fi
  #       fi
  #   }

  #   function delete() {
  #     TYPE=$1
  #     NAME=$2
  #     ID=$3
  #     URL="$PROTO://$DOMAIN/identity/api/${TYPE}"
  #     EXISTS=$(curl --silent --insecure --request DELETE \
  #       --url "$URL/$ID" \
  #       -H "Authorization: Bearer $ACCESS_TOKEN" \
  #       -H "Content-Type: application/json")
  #     # RETURN
  #     echo $(printf '%s' "$EXISTS" | jq '.[0].id // empty')
  #   }

  #   # Checks if the file is an array or object 
  #   # Objects will be returned as an array
  #   function isArray() {
  #     FILE=$1
  #     RET=$(jq -rc '. | if type!="array" then [.] else . end' "$FILE")
  #     echo $RET
  #   }

  #   #If Resource JSON exists. Configure Resource
  #   if [[ -e "${DIRECTORY}/$APP_NAME-resource.json" ]]; then
  #     FILE="${DIRECTORY}/$APP_NAME-resource.json"
  #     isArray $FILE | jq -c '.[]' | while read object; do
  #       NAME=$(printf '%s' "$object" | jq -r '.name')
  #       RESOURCE_ID=$(exists resource $NAME)
        
  #       if [[ -n "$RESOURCE_ID" ]]; then  
  #         # Because of some API limitations, delete the resource and add it again
  #         delete resource $NAME $RESOURCE_ID
  #         add resource $NAME "$object"
  #       else
  #         add resource $NAME "$object"
  #       fi
  #     done
  #   fi


  #   #If a client JSON file exists. Configure Client. 
  #   if [[ -e "${DIRECTORY}/$APP_NAME-client.json" ]]; then
  #     FILE="${DIRECTORY}/$APP_NAME-client.json"
  #     isArray $FILE | jq -c '.[]' | while read object; do
  #       NAME=$(printf '%s' "$object" | jq -r '.name')
  #       CLIENT_ID=$(exists client $NAME)
        
  #       if [[ -n "$CLIENT_ID" ]]; then  
  #         # Because of some API limitations, delete the client and add it again
  #         delete client $NAME $CLIENT_ID
  #         add client $NAME "$object" '. | {name: .name, displayName: .displayName, description: .description}'
  #       else
  #         add client $NAME "$object" '. | {name: .name, displayName: .displayName, description: .description}'
  #       fi
  #     done
  #   fi

  #   #If a account JSON file exists. Create Account as long as it doesn't exist. 
  #   if [[ -e "${DIRECTORY}/$APP_NAME-account.json" ]]; then
  #     FILE="${DIRECTORY}/$APP_NAME-account.json"
  #     isArray $FILE | jq -c '.[]' | while read object; do
  #       USERNAME=$(printf '%s' "$object" | jq -r '.usernames[0]')
  #       ACCOUNT_ID=$(exists account $USERNAME)
        
  #       if [[ -n "$ACCOUNT_ID" ]]; then  
  #         # Because of some API limitations, delete the resource and add it again
  #         echo "Account Exists. Accounts cannot be updated with this script."
  #       else
  #         add account $USERNAME "$object" '. | {usernames: .usernames, password: .password}'
  #       fi
  #     done
  #   fi
